# lec 3 SPOC Discussion

## **提前准备**
（请在上课前完成）


## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
-  BIOS从磁盘读入的第一个扇区是是什么内容？为什么没有直接读入操作系统内核映像？

主引导记录
因为操作系统所在的扇区的文件系统多样，所在的磁盘介质包括硬盘、U盘、光盘等，而且操作系统一般比较大，占据许多个扇区，所以需要通过主引导记录了解文件系统类型、启动项信息，从而能够在后面正确载入目标操作系统。

- 比较UEFI和BIOS的区别。

UEFI存在安全机制，采用签名等方式，而BIOS没有
UEFI的启动配置比BIOS更加灵活通用
UEFI能够支持启动引导比BIOS更大的硬盘空间（>2.1T）

## 3.2 系统启动流程

- 分区引导扇区的结束标志是什么？

0xAA55

- 在UEFI中的可信启动有什么作用？

保证加载程序可信安全，从而保证在系统启动过程中的安全

## 3.3 中断、异常和系统调用比较
- 什么是中断、异常和系统调用？

中断：来自硬件的系统处理请求
异常：非法指令或其他原因导致当前指令执行失败
系统调用：应用程序主动向操作系统发出的对于系统资源的使用请求

-  中断、异常和系统调用的处理流程有什么异同？

相同：都采用中断方式来进行处理，而对应的中断服务程序不同，硬件中断处理硬件的请求，异常则对应异常处理或终止程序，系统调用则返回给程序系统调用的结果

- 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？

read(char* buf, int len)等
功能分类：进程管理、文件操作、设备管理、主存管理、进程通信、信息维护

## 3.4 linux系统调用分析
-  通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(仅实践，不用回答)
- 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(仅实践，不用回答)


## 3.5 ucore系统调用分析 （扩展练习，可选）
-  基于实验八的代码分析ucore的系统调用实现，说明指定系统调用的参数和返回值的传递方式和存放位置信息，以及内核中的系统调用功能实现函数。
- 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
- 以ucore lab8的answer为例，尝试修改并运行ucore OS kernel代码，使其具有类似Linux应用工具`strace`的功能，即能够显示出应用程序发出的系统调用，从而可以分析ucore应用的系统调用执行过程。

 
## 3.6 请分析函数调用和系统调用的区别
- 系统调用与函数调用的区别是什么？

系统调用和函数调用使用的汇编指令不同，如下面一题所示
系统调用涉及用户级到内核级的权限变化，过程中需要权限和安全方面的处理，效率一般比函数调用低

- 通过分析`int`、`iret`、`call`和`ret`的指令准确功能和调用代码，比较函数调用与系统调用的堆栈操作有什么不同？

系统调用需要将大部分寄存器存入堆栈，实现用户态到内核态的转变，而后再进行中断服务例程的处理，再转换回用户态，恢复各个寄存器，继续进行程序执行
而函数调用则没有用户态和内核态之间的转换，因此部分寄存器的内容不需要存入堆栈。

## 课堂实践 （在课堂上根据老师安排完成，课后不用做）
### 练习一
通过静态代码分析，举例描述ucore键盘输入中断的响应过程。

### 练习二
通过静态代码分析，举例描述ucore系统调用过程，及调用参数和返回值的传递方法。
